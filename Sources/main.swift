#!/usr/bin/env swift

#if os(Linux)
import Glibc
#else 
import Darwin
#endif

import Foundation

var _path = NSProcessInfo.processInfo().arguments.dropFirst().last ?? ""
if _path.isEmpty {
	_path = "."
}
var resolved: Int8 = 0
let path = String.fromCString(realpath(_path, &resolved))
print("Path '\(path)'")

struct Error: ErrorType, CustomStringConvertible {
	let reason: String
	init(_ reason: String) {
		self.reason = reason
	}

	var description: String {
		return "Error: \(self.reason)"
	}
}
extension String: ErrorType {}

func allTestFiles(folder: String) throws -> [String] {
	print("Browsing folder \(folder)")
	do {
		let files = try NSFileManager
		.defaultManager()
		.contentsOfDirectoryAtPath(folder)
		var newFiles = files
		if newFiles.count == 0 { return [] }
		newFiles = newFiles.filter { (f: String) -> Bool in 
			let suff = "Tests.swift"
			let match = String(f.characters.suffix(suff.characters.count)) == suff
			return match
		}
		print("Found eligible files \(newFiles)")
		return newFiles
	} catch {
		throw Error("Failed to read from path '\(folder)'")
	}
}

func parseTestFunc(line: String) -> String? {
	let comps = line.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet()).filter { !$0.isEmpty }
	guard comps.count >= 2 else { return nil }
	guard comps[0] == "func" else { return nil }
	guard comps[1].hasPrefix("test") else { return nil }
	//remove trailing parentheses
	return String(comps[1].characters.dropLast(2))
}

func parseClassName(line: String) -> String? {
	let set = NSCharacterSet(charactersInString:":\r\t\n ")
	let comps = line.componentsSeparatedByCharactersInSet(set).filter { !$0.isEmpty }
	guard comps.count >= 2 else { return nil }
	guard comps[0] == "class" else { return nil }
	guard comps[2] == "XCTestCase" else { return nil }
	return comps[1]
}

func generateCode(className className: String, funcs: [String]) -> String {

	func funcLine(funcName: String) -> String {
		return "            (\"\(funcName)\", \(funcName))"
	}

	var comps = [String]()

	//print
	comps.append("extension \(className): XCTestCaseProvider {")
	comps.append("    var allTests : [(String, () throws -> Void)] {")
	comps.append("        return [")
	let all = funcs.map { funcLine($0) }.joinWithSeparator(",\n")
	comps.append(all)
	comps.append("        ]")
	comps.append("    }")
	comps.append("}\n")
	return comps.joinWithSeparator("\n")
}

func generateLinuxMain(moduleName moduleName: String, classNames classNames: [String]) -> String {
	var comps = [String]()

	//print
	comps.append("import XCTest")
	comps.append("import \(moduleName)test")
	comps.append("\n")
	comps.append("XCTMain([")
	let all = classNames.map { "        \($0)()" }.joinWithSeparator(",\n")
	comps.append(all)
	comps.append("])\n\n")
	return comps.joinWithSeparator("\n")
}

func processFile(file: String) throws -> String {

	print("Processing file \(file)")

	let data = try String(contentsOfFile: file, encoding: NSUTF8StringEncoding)
	let allLines = data.componentsSeparatedByString("\n")
	guard let className: String = allLines.flatMap({ parseClassName($0) }).first else {
		throw Error("No XCTestCase found")
	}
	let funcs: [String] = allLines.flatMap { parseTestFunc($0) } //only keep test func candidates
	guard funcs.count > 0 else {
		throw Error("No test functions found in \(file)")
	}

	return generateCode(className: className, funcs: funcs)
}

func generateLinuxTests(files: [String], folder: String) throws {
	let fileOutputs = files.map { try? processFile("\(folder)/\($0)") }.flatMap { $0 }
	let outFile = folder + "/Generated.swift"

	let header = "\n// Generated by SwiftXCTestLinuxNameGenerator\n\n"
	var contents = fileOutputs.joinWithSeparator("\n")
	contents = header + [
		"#if os(Linux)\n",
		contents,
		"#endif\n\n\n"
	].joinWithSeparator("\n")

	//write to disk
	try contents.writeToFile(outFile, atomically: true, encoding: NSUTF8StringEncoding)

	print("File generated at \(outFile)")
}

func createMain(moduleName moduleName: String, classNames classNames: [String]) throws {
	
}

func processFiles(files: [String], folder: String) throws {
	// generate the linux manifest
	try generateLinuxTests(files, folder: folder)
	// generate the LinuxMain.swift which runs them all 
	
}

func run(path: String?) throws {
	guard let testFolder = path else {
		throw Error("Invalid path passed in")
	}
	let files = try allTestFiles(testFolder)
	guard files.count > 0 else {
		throw Error("No files that end with 'Tests.swift'")
	}
	try processFiles(files, folder: testFolder)
}

do {
	try run(path)
	print("done")
	exit(0)
} catch {
	print("\(error)")
	// fatalError("\(error)")
	exit(1)
}








